<!---
, которые живут двойною жизнь.

В одной они обычные переменные, которые могут зависеть от других таких же переменных, ведь у описанного в нашем формате сообщения нет никакого привычного runtime и compile-time, есть лишь время построения.

В другой же они 
-->

# TODO

Добавить для многих оберток над expect и unwrap внутри namespace https://github.com/rust-lang/rfcs/blob/master/text/2091-inline-semantic.md

# General layout concerns and ideas

- В самой идеи __dependo__-buf лежат зависимые типы. Простым примером может служить привычная строка:

```
message MyString {
    len UInt;
    data CharList len;
}
```


## Нюансы

1. __Версионирование.__ Пока что склоняюсь к тому, что сериализация и десериализация объектов должна происходить интерфейсами сгенерированными из одинаковых* прото-файлов с помощью компиляторов одной версии. Ибо в таком случае у оптимизатора будет больше свободы и сгенерированные (де)сериализаторы 
_\*_ важным нюансом является то, что обновление модуля, используемого в прото-файле, приводит к изменению этого файла. То есть любое обновление должно производиться одновременно везде. Разумеется в реальной жизни такое не выполнимо. Одним из возможных решений возможно является следующее: при запланированном обновлении можно независимо переводить интерфейсы на более медленный и менее строгий.

## Field layout

Идею small-string-optimization можно расширить дальше при сериализации объектов. Рассмотрим любой объект с динамическим (возможно даже для объектов с статическим размером это тоже применимо) размером. Он может либо быть помещен сразу после своей метаинформации (это длина и все?), либо быть размещен ближе к концу сообщения (в таком случае метаинформация: сдвиг и длина). У обоих вариантов есть плюсы и минусы:

1. Можем прочитать мету и вместе с ней прочитать уже часть объекта или даже его весь. Для маленьких объектов (меньших кеш линии) это экономит один доступ в память.

2. Если объект достаточно длинный, то один раз промахнуться по кешу будет не критично для прочтения всего объекта. И за счет этого мы можем больше объектов поместить.

# Some samples

```
message ConstInt (n Int) {}

enum Collatz (n Int) (depth Int) {
    impl CollatzImpl (n) (n % 2) (depth)
}

enum CollatzImpl (n Int) (n_parity Int) (depth Int) {
    1, _, _ => {
        Result {
            result ConstInt (depth)
        }
    }
    _, 0, _ => {
        EvenStep {
            next0 Collatz (n / 2) (depth + 1)
        }
    }
    _, 1, _ => {
        OddStep {
            next1 Collatz (3 * n + 1) (depth + 1)
        }
    }
    _, _, _ => {
        #[unreachable] {}
    }
}
```

```
message ConstInt (n Int) {}

enum Killer (n Int) (m Int) (t1 ConstInt (n % 3)) (t2 ConstInt (m % 3)) {
    _, _, ConstInt (0) {}, ConstInt (0) {} => {
        Case00 {
            ...
        }
    }
    ...
}
```

# Some questions/ideas/proposes/concerns

### ЗАЧЕМ ВСЕ ЭТО ДЕЛАЕТСЯ. Я ПЫТАЮСЬ ПРОДУМАТЬ ПРИМЕНЕНИЯ И У МЕНЯ НИЧЕГО НЕ ВЫХОДИТ.

Система сообщений является тьюринг-полной. Но зачем кому-то нужно тьюринг-полное сообщение? Зачем вычислять что либо не тривиальное в сообщениях. 

### Access для доступа к зависимостям сообщения

Судя по наличию Access унарного оператора в аст, доступ к полям сообщения есть, по аналогии хочется иметь доступ к зависимостям сообщения. 

Его отсутствие делает зависимости и поля асимметричными, хотя по задумке они кажется подразумеваются симметричными.

Также асимметрия наблюдается в создании констант. Например в данный момент невозможно задать константный `Int` как поле. Но можно сделать следующее:

```
message ConstInt (value Int) {}

message IWantConstICreateIt {
    const ConstInt (228);
}

message Sum {
    a Int;
    b Int;
    sum ConstInt (a + b)
}
```

Таким образом можно генерировать функции на разные языки, семантику которых можно гарантировать одинаковой. Это точно реально, т.к. на детерминированность вычислений опираются много. Однако это сильно ограничивает возможности оптимизатора. Например сложение множества float друг с другом уже может иметь различное поведение на разных языках (в силу переупорядочивания). Как добиться здесь строгости я пока что не знаю.

### При введении типов как параметров кажется логичным вводить какие-то интерфейсы

Из интересного: методы класса в обычном языке программирования и поля сообщения в протоколе не отличаются особо.

### Зависимости (generic parameters) сообщений всегда являются runtime параметром в любом из языков

Настоящая необходимость иметь параметры не runtime возникнет лишь при добавлении типов в качестве возможных значений в протокол. Для таких настоящих compile-time парамеров можно например вводить built-in тип, которым можно обернуть параметр:

```
// No need to serialize (except for debugging purposes) T and U because serializer will choose types
// So, such pure message is unsafe to use if types can be arbitrary
message Pair (T Const (Any)) (U Const (Any)) {
    T first;
    U second;
}
```

### Static array (aka [T; N] или T[N])

Разумеется его можно выразить (но лишь рекурсивно) в существующей версии языка (протокола). Например так:

```
message List (n UInt) {
    0 => {
        Nil {}
    }
    _ => {
        ListNode {
            value Int // In general can be any type
            tail List (n - 1)   
        }
    }
}
```

- В связи с рекурсивной спецификой этого сообщения, его просто невозможно написать на C++ или Расте без динамического выделения памяти (`std::shared_ptr`/`std::rc::Rc`), т.к. у структуры нет известного размера в момент компиляции интерфейса.

- Также есть проблема при сериализации: в корневом сообщении `List (n)` при фиксированном `n`. Само `n` мы сериализовать обязаны, но должны ли мы сериализовать `n - c` для всех `0 < c <= n` при сериализации поля `next`? Со стороны конечно очевидно, что не нужно, на деле это вопрос для оптимизатора layout'а сообщения.  
И такой оптимизатор не может быть реализован тривиально: например просто отбрасывая параметры всегда. Например функция из проблемы Коллатца не может быть легко вычислена по данному числу. А значит вычислить длину массива можно лишь за `O()` от длины.

- Задавать руками такую конструкцию неприятно: `[1, 2, 3]`  
или  `ListNode{1, ListNode{2, ListNode{3, Nil{}}}}`

Мне кажется разумным вариантом было бы сделать список built-in сообщением. Возможно даже позволить ему иметь зависимость по типу внутри, чтобы не иметь дело с ListChar, ListInt, ...

### Attributes for modules, messages, fields, etc.

Для целей оптимизатора и удобства пользователя кажется разумным добавление различных атрибутов. 

Примеры:

- Указывать, под что оптимизировать данный модуль/сообщение: размер при сериализации, время (де)сериализации, размер бинарника.  

- Указывать область видимости сообщений. Если сообщение является приватным, то для него не обязательно генерировать интерфейс. И при оптимизации может быть вставлено в другие сообщения целиком.

- Указывать, нужно ли интерфейсу уметь принимать сообщения других версий (поля, которые не подходят под текущую версию не будут вызывать ошибку). Полезно, если получатель сообщение перенаправляет сообщения и возможно читает некоторые поля.

Синтаксис вроде `#[private]` уже будет достаточным.
